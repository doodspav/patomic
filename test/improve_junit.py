import argparse
import xml.etree.ElementTree as ETree

from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional


@dataclass
class ProgArgs:
    input_path: Path
    output_path: Path
    triple: str


def get_program_arguments() -> ProgArgs:
    # define program arguments
    parser = argparse.ArgumentParser(description="Tidy up CTest's JUnit XML to more closely match GTest output.")
    parser.add_argument("-i", "--input", type=str, required=True, help="JUnit XML file generated by CTest")
    parser.add_argument("-o", "--output", type=str, required=True, help="File path to write output into")
    parser.add_argument("-t", "--triple", type=str, required=True, help="Platform identifier on which input file was generated from")

    # obtain program arguments
    args = parser.parse_args(args=["-i", "x86_32-ubuntu-gcc-shared.xml", "-t", "x86_32-ubuntu-gcc-shared", "-o", "results.xml"])
    return ProgArgs(input_path=Path(args.input), output_path=Path(args.output), triple=args.triple)


def _make_default_gtest_testsuite_element(suite_name: str) -> ETree.Element:
    elem = ETree.Element("testsuite")
    elem.attrib.update({
        "name": suite_name,
        "tests": "0",
        "failures": "0",
        "disabled": "0",
        "skipped": "0",
        "errors": "0",
        "time": "0."
    })
    return elem


def _make_gtest_result(suite_name: str, case_name: str, status: str, sysout: str) -> Optional[str]:
    # test crashed
    if status == "fail":
        return None

    # test was either skipped while running, or not run at all
    elif status == "notrun":
        if f"[  SKIPPED ] {suite_name}.{case_name}" in sysout:
            return "skipped"
        else:
            return None

    # test was run to completion, but may have failed
    elif status == "run":
        if f"[  FAILED  ] {suite_name}.{case_name}" in sysout:
            return "failed"
        else:
            return "completed"

    # should be unreachable
    else:
        raise ValueError(f"status attribute of {suite_name}.{case_name} has unknown value: {status}")


def _add_gtest_case_to_suite(case: ETree.Element, suite: ETree.Element) -> None:
    # helper lambda
    inc_attr = lambda elem, key: elem.set(key, str(int(elem.get(key)) + 1))

    # increment time and tests count
    inc_attr(suite, "tests")
    new_time = str(float(suite.get("time")) + float(case.get("time")))
    if "." not in new_time:
        new_time += "."
    suite.set("time", new_time)

    # increment diagnostic counters
    status: str = case.get("status")
    result: Optional[str] = case.get("result")
    if status == "notrun":
        inc_attr(suite, "disabled")
    elif status == "run":
        if result == "failed":
            inc_attr(suite, "failures")
        elif result == "skipped":
            inc_attr(suite, "skipped")
    else:
        inc_attr(suite, "errors")

    # slot case into suite
    suite.append(case)


def _parse_gtest_testsuites_from_ctest_testsuite_element(root_elem: ETree.Element) -> List[ETree.Element]:
    # get all test cases, mapped to gtest testsuite element
    test_suites: Dict[str, ETree.Element] = {}
    for elem_testcase in root_elem:

        # all testcase element names are expected to be "Suite.Case" fromat
        suite_name, case_name = elem_testcase.get("name").split('.', maxsplit=1)
        elem_testcase.set("name", case_name)
        elem_testcase.set("classname", suite_name)

        # make sure we recognise status
        status: str = elem_testcase.get("status")
        if status not in ["run", "notrun", "fail"]:
            raise ValueError(f"status attribute of {suite_name}.{case_name} has unknown value: {status}")

        # remove <system-out> child element if test runs with no issues
        sysout: str = ""
        if status == "run":
            all_elem_sysout = elem_testcase.findall("system-out")
            if len(all_elem_sysout) > 1:
                raise ValueError(f"more than one <system-out> sub-element found in {suite_name}.{case_name}")
            if len(all_elem_sysout) > 0:
                sysout = "" if all_elem_sysout[0].text is None else str(all_elem_sysout[0].text)
            sysout_lower = sysout.lower()
            if not any(s in sysout_lower for s in ["error", "fail", "warn"]):
                elem_testcase.remove(all_elem_sysout[0])

        # set result to gtest values
        result = _make_gtest_result(suite_name, case_name, status, sysout)
        if result is not None:
            elem_testcase.set("result", result)
        if result == "skipped":
            elem_testcase.set("status", "run")

        # populate dictionary
        elem_testsuite = test_suites.get(suite_name)
        if elem_testsuite is None:
            elem_testsuite = _make_default_gtest_testsuite_element(suite_name)
        _add_gtest_case_to_suite(elem_testcase, elem_testsuite)
        test_suites[suite_name] = elem_testsuite

    # return all testsuites
    return list(test_suites.values())


def make_gtest_root(triple: str, ctest_root: ETree.Element) -> ETree.Element:
    # make root element
    gtest_root = ETree.Element("testsuites")
    gtest_root.attrib.update({
        "name": triple,
        "tests": ctest_root.get("tests"),
        "failures": "0",
        "disabled": "0",
        "skipped": "0",
        "errors": "0",
        "time": "0.",
        "timestamp": ctest_root.get("timestamp")
    })

    # helper lambda
    add_attr = lambda elem, from_, key: elem.set(key, str(int(elem.get(key)) + int(from_.get(key))))

    # get attributes from all suites
    gtest_suites = _parse_gtest_testsuites_from_ctest_testsuite_element(ctest_root)
    for suite in gtest_suites:

        # increment time
        new_time = str(float(gtest_root.get("time")) + float(suite.get("time")))
        if "." not in new_time:
            new_time += "."
        gtest_root.set("time", new_time)

        add_attr(gtest_root, suite, "failures")
        add_attr(gtest_root, suite, "disabled")
        add_attr(gtest_root, suite, "skipped")
        add_attr(gtest_root, suite, "errors")

        # add as child element
        gtest_root.append(suite)

    # return complete root
    return gtest_root


if __name__ == "__main__":

    prog_args = get_program_arguments()

    # parse input file as xml
    input_tree = ETree.parse(prog_args.input_path)
    input_root = input_tree.getroot()

    # create output
    output_root = make_gtest_root(prog_args.triple, input_root)

    # write output
    output_tree = ETree.ElementTree(output_root)
    ETree.indent(output_tree)
    output_tree.write(prog_args.output_path, encoding="utf-8", xml_declaration=True)
