# Copyright (c) doodspav.
# SPDX-License-Identifier: LGPL-3.0-or-later WITH LGPL-3.0-linking-exception

import argparse
import xml.etree.ElementTree as ETree

from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional


@dataclass
class ProgArgs:
    input_path: Path
    output_path: Path
    triple: str


def get_program_arguments() -> ProgArgs:
    # define program arguments
    parser = argparse.ArgumentParser(description="Tidy up CTest's JUnit XML to more closely match GTest output.")
    parser.add_argument("-i", "--input", type=str, required=True, help="JUnit XML file generated by CTest")
    parser.add_argument("-o", "--output", type=str, required=True, help="File path to write output into")
    parser.add_argument("-t", "--triple", type=str, required=True, help="Platform identifier on which input file was generated from")

    # obtain program arguments
    args = parser.parse_args()
    return ProgArgs(input_path=Path(args.input), output_path=Path(args.output), triple=args.triple)


def _make_gtest_default_testsuite(suite_name: str) -> ETree.Element:
    elem = ETree.Element("testsuite")
    elem.attrib.update({
        "name": suite_name,
        "tests": "0",
        "failures": "0",
        "disabled": "0",
        "skipped": "0",
        "errors": "0",
        "time": "0."
    })
    return elem


def _make_gtest_testcase_result(suite_name: str, case_name: str, status: str, sysout: str) -> Optional[str]:
    # test failed, possibly crashed
    if status == "fail":
        if f"[  FAILED  ] {suite_name}.{case_name}" in sysout:
            return "failed"
        else:
            return "crashed"

    # test was either skipped while running, or not run at all
    elif status == "notrun":
        if f"[  SKIPPED ] {suite_name}.{case_name}" in sysout:
            return "skipped"
        else:
            return None

    # test was run to completion
    elif status == "run":
        return "completed"

    # should be unreachable
    else:
        raise ValueError(f"status attribute of {suite_name}.{case_name} has unknown value: {status}")


def _add_gtest_testcase_to_testsuite(suite: ETree.Element, case: ETree.Element) -> ETree.Element:
    # helper lambda
    inc_attr = lambda elem, key: elem.set(key, str(int(elem.get(key)) + 1))

    # increment time and tests count
    inc_attr(suite, "tests")
    new_time = str(float(suite.get("time")) + float(case.get("time")))
    if '.' not in new_time:
        new_time += '.'
    suite.set("time", new_time)

    # increment diagnostic counters
    status: str = case.get("status")
    result: Optional[str] = case.get("result")
    if status == "run":
        if result == "completed":
            pass
        elif result == "skipped":
            inc_attr(suite, "skipped")
        elif result == "failed":
            inc_attr(suite, "failures")
        elif result == "crashed":
            inc_attr(suite, "errors")
        else:
            raise ValueError(f"result attribute of {suite.get('name')}.{case.get('name')} has unknown value: {result}")
    elif status == "notrun":
        inc_attr(suite, "disabled")
    else:
        raise ValueError(f"status attribute of {suite.get('name')}.{case.get('name')} has unknown value: {status}")

    # attach case to suite
    suite.append(case)
    return suite


def _parse_gtest_testsuites_from_ctest_testsuite(ctest_testsuite: ETree.Element) -> List[ETree.Element]:
    # get all gtest testsuite names, mapped to their elements
    gtest_suites: Dict[str, ETree.Element] = {}
    for case in ctest_testsuite:

        # all testcase element names are expected to be "Suite.Case" format
        suite_name, case_name = case.get("name").split('.', maxsplit=1)
        case.set("name", case_name)
        case.set("classname", suite_name)

        # make sure we recognise status
        status: str = case.get("status")
        if status not in ["run", "notrun", "fail"]:
            raise ValueError(f"status attribute of {suite_name}.{case_name} has unknown value: {status}")

        # get <system-out> sub-element for checking later
        sysout: str = ""
        all_elem_sysout = case.findall("system-out")
        if len(all_elem_sysout) > 1:
            raise ValueError(f"more than one <system-out> sub-element found in {suite_name}.{case_name}")
        if len(all_elem_sysout) > 0:
            sysout = "" if all_elem_sysout[0].text is None else str(all_elem_sysout[0].text)

        # remove <system-out> sub-element if test runs with no issues
        if status in "run" and sysout and not any(s in sysout.lower() for s in ["warn", "error", "fail"]):
            case.remove(all_elem_sysout[0])

        # set result to gtest values
        result = _make_gtest_testcase_result(suite_name, case_name, status, sysout)
        if result is not None:
            case.set("result", result)
        if status == "fail" or result == "skipped":
            case.set("status", "run")

        # populate dictionary
        suite = gtest_suites.get(suite_name)
        if suite is None:
            suite = _make_gtest_default_testsuite(suite_name)
        gtest_suites[suite_name] = _add_gtest_testcase_to_testsuite(suite, case)

    # return all suites
    return list(gtest_suites.values())


def convert_ctest_root_to_gtest_root(triple: str, ctest_root: ETree.Element) -> ETree.Element:
    # helper lambda
    add_attr = lambda elem, from_, key: elem.set(key, str(int(elem.get(key)) + int(from_.get(key))))

    # make gtest root element
    gtest_root = ETree.Element("testsuites")
    gtest_root.attrib.update({
        "name": triple,
        "tests": ctest_root.get("tests"),
        "failures": "0",
        "disabled": "0",
        "skipped": "0",
        "errors": "0",
        "time": "0.",
        "timestamp": ctest_root.get("timestamp")
    })

    # get attributes from all suites
    gtest_suites = _parse_gtest_testsuites_from_ctest_testsuite(ctest_root)
    for suite in gtest_suites:

        # increment time
        new_time = str(float(gtest_root.get("time")) + float(suite.get("time")))
        if '.' not in new_time:
            new_time += '.'
        gtest_root.set("time", new_time)

        # increment diagnostic counters
        add_attr(gtest_root, suite, "failures")
        add_attr(gtest_root, suite, "disabled")
        add_attr(gtest_root, suite, "skipped")
        add_attr(gtest_root, suite, "errors")

        # add as sub-element
        gtest_root.append(suite)

    # return complete root
    return gtest_root


if __name__ == "__main__":

    args = get_program_arguments()

    # parse input file as xml
    ctest_tree = ETree.parse(args.input_path)
    ctest_root = ctest_tree.getroot()

    # convert to gtest
    gtest_root = convert_ctest_root_to_gtest_root(args.triple, ctest_root)
    gtest_tree = ETree.ElementTree(gtest_root)

    # write gtest xml
    ETree.indent(gtest_tree)
    gtest_tree.write(args.output_path, encoding="utf-8", xml_declaration=True)
